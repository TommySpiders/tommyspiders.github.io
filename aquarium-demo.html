<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aquarium Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

  <style>
    /* Force landscape on phones */
    @media screen and (orientation: portrait) {
      body::before {
        content: "Please rotate your device";
        position: fixed;
        inset: 0;
        background: #000;
        color: #fff;
        font-size: 26px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 99999;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e8f6ff;
      touch-action: none;
    }

    /* CAMERA + WORLD (3√ó wide tank) */
    #camera {
      position: fixed;
      inset: 0;
      overflow: hidden;
      touch-action: none;
    }

    #world {
      position: absolute;
      left: 0;
      top: 0;
      width: 300vw;
      height: 100vh;
      background-image: url("bg-underwater.PNG");
      background-size: 300vw 100vh;
      background-repeat: no-repeat;
      transform-origin: top left;
    }

    /* Flowing water FX */
    #causticsLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.25;
      background-image:
        radial-gradient(circle at 10% 0%, rgba(255,255,255,0.4), transparent 55%),
        radial-gradient(circle at 80% 20%, rgba(255,255,255,0.32), transparent 55%),
        radial-gradient(circle at 20% 60%, rgba(255,255,255,0.24), transparent 55%),
        radial-gradient(circle at 90% 90%, rgba(255,255,255,0.22), transparent 55%);
      background-size: 220% 220%;
      animation: causticsFlow 18s linear infinite;
    }

    @keyframes causticsFlow {
      0%   { transform: translate3d(0,   0,   0) scale(1.1); }
      50%  { transform: translate3d(-6%, 4%, 0) scale(1.15); }
      100% { transform: translate3d(5%, -3%, 0) scale(1.1); }
    }

    #dustLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.22;
      background-image:
        radial-gradient(circle at 15% 20%, rgba(255,255,255,0.55), transparent 55%),
        radial-gradient(circle at 60% 10%, rgba(255,255,255,0.4), transparent 55%),
        radial-gradient(circle at 35% 75%, rgba(255,255,255,0.45), transparent 55%),
        radial-gradient(circle at 85% 60%, rgba(255,255,255,0.38), transparent 55%);
      background-size: 260% 260%;
      animation: dustDrift 32s linear infinite;
      mix-blend-mode: screen;
    }

    @keyframes dustDrift {
      0%   { transform: translate3d(0,   0,   0) scale(1); }
      50%  { transform: translate3d(4%, -4%, 0) scale(1.05); }
      100% { transform: translate3d(-3%, 5%, 0) scale(1); }
    }

    #waterTint {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at 50% 0%, rgba(150,230,255,0.22), transparent 55%);
      mix-blend-mode: soft-light;
    }

    /* Bubble emitters */
    .bubbleColumn {
      position: absolute;
      bottom: 0;
      width: 60px;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
    }

    #bubblesLeft  { left: 8vw; }
    #bubblesCenter{ left: 150vw; }
    #bubblesRight { right: 8vw; }

    .bubble {
      position: absolute;
      bottom: -40px;
      left: 12px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.8);
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(160,220,255,0.4));
      opacity: 0.8;
      animation: rise 6s linear infinite;
    }
    .bubble.small {
      width: 8px;
      height: 8px;
      left: 4px;
      animation-duration: 7.5s;
      opacity: 0.7;
    }
    .bubble.large {
      width: 16px;
      height: 16px;
      left: 24px;
      animation-duration: 5s;
      opacity: 0.9;
    }

    @keyframes rise {
      0% {
        transform: translateY(0) translateX(0);
        opacity: 0;
      }
      10% {
        opacity: 0.8;
      }
      100% {
        transform: translateY(-110vh) translateX(10px);
        opacity: 0;
      }
    }

    /* FISH LAYER */
    #fishLayer {
      position: absolute;
      inset: 0;
      width: 300vw;
      height: 100vh;
      overflow: visible;
      pointer-events: none;
    }

    /* REALISTIC GUPPY SPRITE */
    .fish {
      position: absolute;
      width: 140px;                /* tweak if too big/small */
      height: 80px;
      background-image: url("guppy1.PNG");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transform-origin: 50% 50%;
      pointer-events: auto;
      filter: drop-shadow(0 6px 8px rgba(0,0,0,0.45));
    }
    .fish::before,
    .fish::after {
      content: none;
    }

    /* UI: 45px bubble buttons */
    .bubbleBtn {
      position: fixed;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffffff, #b7e4ff, #5bc2ff);
      border: 2px solid rgba(255,255,255,0.6);
      box-shadow: 0 0 12px rgba(0,140,255,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      cursor: pointer;
      user-select: none;
      transition: transform 0.08s ease;
      z-index: 5000;
    }
    .bubbleBtn:active {
      transform: scale(0.9);
    }

    #feedBtn  { left: 10px;  top: 22%; }
    #cleanBtn { left: 10px;  top: 42%; }
    #buyBtn   { right: 10px; top: 22%; }
    #shopBtn  { right: 10px; top: 42%; }

    /* Coin bubble */
    #coinBubble {
      position: fixed;
      top: 18px;
      right: 24px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff4a6, #e1a800);
      border: 2px solid rgba(255,255,255,0.6);
      box-shadow: 0 0 10px rgba(255,210,100,0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #603800;
      font-weight: bold;
      user-select: none;
      z-index: 5000;
      font-size: 11px;
    }
    #coinBubble span {
      font-size: 14px;
    }

    /* Fish info panel */
    #fishInfoPanel {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 280px;
      padding: 16px;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.16);
      backdrop-filter: blur(12px);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.45);
      color: #ffffff;
      display: none;
      z-index: 9000;
      box-shadow: 0 0 18px rgba(0,0,0,0.7);
    }
    #fishInfoPanel h2 {
      margin-bottom: 8px;
      font-size: 18px;
    }
    #fishInfoPanel p {
      margin-bottom: 4px;
      font-size: 14px;
    }
    #closeFishInfo {
      margin-top: 10px;
      padding: 8px;
      background: rgba(255,255,255,0.25);
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.4);
      text-align: center;
      cursor: pointer;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <div id="camera">
    <div id="world">
      <div id="causticsLayer"></div>
      <div id="dustLayer"></div>
      <div id="waterTint"></div>

      <div id="bubblesLeft" class="bubbleColumn">
        <div class="bubble small"></div>
        <div class="bubble"></div>
        <div class="bubble large"></div>
      </div>
      <div id="bubblesCenter" class="bubbleColumn">
        <div class="bubble"></div>
        <div class="bubble small"></div>
        <div class="bubble large"></div>
      </div>
      <div id="bubblesRight" class="bubbleColumn">
        <div class="bubble small"></div>
        <div class="bubble"></div>
        <div class="bubble large"></div>
      </div>

      <div id="fishLayer"></div>
    </div>
  </div>

  <div id="coinBubble">
    ü™ô
    <span id="coinCount">80</span>
  </div>

  <div id="feedBtn"  class="bubbleBtn">üç§</div>
  <div id="cleanBtn" class="bubbleBtn">üßΩ</div>
  <div id="buyBtn"   class="bubbleBtn">üê†</div>
  <div id="shopBtn"  class="bubbleBtn">üõí</div>

  <div id="fishInfoPanel">
    <h2 id="fishName">Fish</h2>
    <p><strong>Health:</strong> <span id="fishHealth"></span>%</p>
    <p><strong>Hunger:</strong> <span id="fishHunger"></span>%</p>
    <p><strong>Value:</strong> <span id="fishValue"></span> coins</p>
    <p><strong>Age:</strong> <span id="fishAge"></span> days</p>
    <div id="closeFishInfo">Close</div>
  </div>

  <script>
    // basic state
    let coins = 80;
    const coinCountEl = document.getElementById("coinCount");

    let fishList = [];
    let nextFishId = 1;

    const cameraEl = document.getElementById("camera");
    const worldEl  = document.getElementById("world");
    const fishLayerEl = document.getElementById("fishLayer");

    const fishInfoPanel   = document.getElementById("fishInfoPanel");
    const fishNameEl      = document.getElementById("fishName");
    const fishHealthEl    = document.getElementById("fishHealth");
    const fishHungerEl    = document.getElementById("fishHunger");
    const fishValueEl     = document.getElementById("fishValue");
    const fishAgeEl       = document.getElementById("fishAge");
    const closeFishInfoEl = document.getElementById("closeFishInfo");

    const feedBtn  = document.getElementById("feedBtn");
    const cleanBtn = document.getElementById("cleanBtn");
    const buyBtn   = document.getElementById("buyBtn");
    const shopBtn  = document.getElementById("shopBtn");

    // camera
    let camX = 0, camY = 0, camScale = 1.0;
    const MIN_SCALE = 0.8, MAX_SCALE = 2.2;
    let isDragging = false;
    let lastPointerX = 0, lastPointerY = 0;
    let pinchActive = false, lastPinchDist = 0;

    function getWorldWidth()  { return window.innerWidth * 3; }
    function getWorldHeight() { return window.innerHeight; }

    function clampCamera() {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const worldWidth  = getWorldWidth()  * camScale;
      const worldHeight = getWorldHeight() * camScale;

      const minX = vw - worldWidth;
      const maxX = 0;
      if (worldWidth <= vw) {
        camX = (vw - worldWidth) / 2;
      } else {
        camX = Math.max(minX, Math.min(maxX, camX));
      }

      const verticalRange = vh * 0.06; // small up/down
      const minY = -verticalRange;
      const maxY =  verticalRange;
      camY = Math.max(minY, Math.min(maxY, camY));
    }

    function applyCameraTransform() {
      worldEl.style.transform = `translate(${camX}px, ${camY}px) scale(${camScale})`;
    }

    function centerCamera() {
      const vw = window.innerWidth;
      const worldWidth = getWorldWidth() * camScale;
      camX = vw / 2 - worldWidth / 2;
      camY = 0;
      clampCamera();
      applyCameraTransform();
    }

    window.addEventListener("resize", () => {
      clampCamera();
      applyCameraTransform();
    });

    function distanceTouches(e) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      return Math.hypot(dx, dy);
    }

    cameraEl.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        isDragging = true;
        pinchActive = false;
        lastPointerX = e.touches[0].clientX;
        lastPointerY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        isDragging = false;
        pinchActive = true;
        lastPinchDist = distanceTouches(e);
      }
    }, { passive: false });

    cameraEl.addEventListener("touchmove", (e) => {
      e.preventDefault();
      if (pinchActive && e.touches.length === 2) {
        const newDist = distanceTouches(e);
        const factor  = newDist / lastPinchDist;
        lastPinchDist = newDist;
        camScale *= factor;
        camScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, camScale));
        clampCamera();
        applyCameraTransform();
      } else if (isDragging && e.touches.length === 1) {
        const x = e.touches[0].clientX;
        const y = e.touches[0].clientY;
        camX += (x - lastPointerX);
        camY += (y - lastPointerY);
        lastPointerX = x;
        lastPointerY = y;
        clampCamera();
        applyCameraTransform();
      }
    }, { passive: false });

    cameraEl.addEventListener("touchend", () => {
      pinchActive = false;
      isDragging = false;
    });

    cameraEl.addEventListener("mousedown", (e) => {
      isDragging = true;
      lastPointerX = e.clientX;
      lastPointerY = e.clientY;
    });
    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      camX += (e.clientX - lastPointerX);
      camY += (e.clientY - lastPointerY);
      lastPointerX = e.clientX;
      lastPointerY = e.clientY;
      clampCamera();
      applyCameraTransform();
    });
    window.addEventListener("mouseup", () => { isDragging = false; });

    function updateCoins() {
      coinCountEl.textContent = Math.floor(coins);
    }

    function randomBetween(min, max) {
      return min + Math.random() * (max - min);
    }

    // create guppy
    function createFish() {
      if (coins < 20) return;
      coins -= 20;
      updateCoins();

      const worldWidth = getWorldWidth();
      const worldHeight = getWorldHeight();

      const id = nextFishId++;
      const x = Math.random() * (worldWidth - 200) + 100;
      const y = Math.random() * (worldHeight * 0.6) + worldHeight * 0.2;

      const personality = Math.random() < 0.5 ? "calm" : "lively";
      const baseSpeed = personality === "calm"
        ? randomBetween(15, 22)
        : randomBetween(22, 32);

      const sizeScale = randomBetween(0.8, 1.15);

      const fish = {
        id,
        x,
        y,
        angle: Math.random() * Math.PI * 2,
        targetAngle: Math.random() * Math.PI * 2,
        displayAngle: 0,
        baseSpeed,
        personality,
        turnTimer: randomBetween(1.5, 4),
        health: 100,
        hunger: 0,
        age: 0,
        value: 10,
        sizeScale,
        el: null
      };

      const el = document.createElement("div");
      el.className = "fish";
      el.style.left = `${fish.x}px`;
      el.style.top  = `${fish.y}px`;

      fish.el = el;
      fishLayerEl.appendChild(el);
      fishList.push(fish);
    }

    // fish info panel
    function showFishInfo(fish) {
      fishNameEl.textContent   = `Guppy #${fish.id} (${fish.personality})`;
      fishHealthEl.textContent = Math.round(fish.health);
      fishHungerEl.textContent = Math.round(fish.hunger);
      fishValueEl.textContent  = Math.round(fish.value);
      fishAgeEl.textContent    = fish.age.toFixed(1);
      fishInfoPanel.style.display = "block";
    }
    closeFishInfoEl.addEventListener("click", () => {
      fishInfoPanel.style.display = "none";
    });

    // hook fish click
    fishLayerEl.addEventListener("click", (e) => {
      const target = e.target.closest(".fish");
      if (!target) return;
      const id = Number(target.dataset.id);
      const fish = fishList.find(f => f.id === id);
      if (fish) showFishInfo(fish);
    });

    // buttons
    feedBtn.addEventListener("click", () => {
      if (coins < 5 || fishList.length === 0) return;
      coins -= 5;
      fishList.forEach(f => {
        f.hunger = Math.max(0, f.hunger - 35);
      });
      updateCoins();
    });

    cleanBtn.addEventListener("click", () => {
      if (coins < 10 || fishList.length === 0) return;
      coins -= 10;
      fishList.forEach(f => {
        f.health = Math.min(100, f.health + 20);
      });
      updateCoins();
    });

    buyBtn.addEventListener("click", () => { createFish(); });
    shopBtn.addEventListener("click", () => { alert("Shop coming soon!"); });

    // fish movement
    function shortestAngleDelta(a, b) {
      let diff = b - a;
      while (diff >  Math.PI) diff -= Math.PI * 2;
      while (diff < -Math.PI) diff += Math.PI * 2;
      return diff;
    }

    function updateFishMovement(dt) {
      const worldWidth  = getWorldWidth();
      const worldHeight = getWorldHeight();

      for (const f of fishList) {
        const steerStrength = (f.personality === "calm" ? 0.4 : 0.8);
        const turnSpeed = steerStrength * dt;

        f.turnTimer -= dt;
        if (f.turnTimer <= 0) {
          const spread = (f.personality === "calm" ? Math.PI / 5 : Math.PI / 3);
          const randomOffset = (Math.random() - 0.5) * spread;
          f.targetAngle = f.angle + randomOffset;
          f.turnTimer = randomBetween(1.0, 3.5);
        }

        const delta = shortestAngleDelta(f.angle, f.targetAngle);
        f.angle += delta * turnSpeed;

        const speed = f.baseSpeed * (0.6 + (f.health / 200));
        f.x += Math.cos(f.angle) * speed * dt;
        f.y += Math.sin(f.angle) * speed * dt;

        const marginX = 100;
        const marginTop = 60;
        const marginBottom = 90;

        let bounced = false;

        if (f.x < marginX) {
          f.x = marginX;
          f.targetAngle = Math.random() * Math.PI - Math.PI / 2;
          bounced = true;
        } else if (f.x > worldWidth - marginX) {
          f.x = worldWidth - marginX;
          f.targetAngle = Math.random() * Math.PI + Math.PI / 2;
          bounced = true;
        }

        if (f.y < marginTop) {
          f.y = marginTop;
          f.targetAngle = (Math.random() * Math.PI) + Math.PI / 2;
          bounced = true;
        } else if (f.y > worldHeight - marginBottom) {
          f.y = worldHeight - marginBottom;
          f.targetAngle = (Math.random() * Math.PI) - Math.PI / 2;
          bounced = true;
        }

        if (bounced) {
          f.turnTimer = randomBetween(0.5, 1.3);
        }

        // smooth visual angle
        const angDelta = shortestAngleDelta(f.displayAngle, f.angle);
        f.displayAngle += angDelta * Math.min(5 * dt, 1); // smoothing factor

        f.el.style.left = `${f.x}px`;
        f.el.style.top  = `${f.y}px`;
        const deg = f.displayAngle * 180 / Math.PI;
        f.el.style.transform = `rotate(${deg}deg) scale(${f.sizeScale || 1})`;
        f.el.dataset.id = f.id;
      }
    }

    // logic tick
    let logicAccumulator = 0;
    function logicTick() {
      let income = 0;
      for (const f of fishList) {
        f.hunger = Math.min(100, f.hunger + 1.2);

        if (f.hunger > 70) {
          f.health = Math.max(0, f.health - 1.2);
        } else if (f.hunger < 40) {
          f.health = Math.min(100, f.health + 0.4);
        }

        f.age += 1 / 30;
        f.value = 8 + (f.health / 5) + (f.age * 0.3);
        income += (f.health / 100) * 0.6;
      }
      coins += income;
      updateCoins();
    }

    // main loop
    let lastTime = null;
    function frame(ts) {
      if (lastTime == null) lastTime = ts;
      const dt = (ts - lastTime) / 1000;
      lastTime = ts;

      updateFishMovement(dt);

      logicAccumulator += dt;
      while (logicAccumulator >= 1.0) {
        logicAccumulator -= 1.0;
        logicTick();
      }

      requestAnimationFrame(frame);
    }

    function initGame() {
      updateCoins();
      camScale = 1.0;
      centerCamera();
      createFish();
      createFish();
      requestAnimationFrame(frame);
    }

    initGame();
  </script>
</body>
</html>
